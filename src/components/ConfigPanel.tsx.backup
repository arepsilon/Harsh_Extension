import { useState, useMemo, useEffect } from 'react';
import type { ReactNode } from 'react';
import type { TableauWorksheet, TableauDataTable } from '../types';
import { PivotEngine } from '../engine/PivotEngine';
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';
import type { DragEndEvent } from '@dnd-kit/core';
import { SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import { SortableItem } from './SortableItem';
import { ManualSortModal } from './ManualSortModal';
import { CalculationEditor } from './CalculationEditor';

interface ConfigPanelProps {
    onClose: () => void;
    worksheets: TableauWorksheet[];
    selectedWorksheet: TableauWorksheet | null;
    onSelectWorksheet: (worksheet: TableauWorksheet) => void;
    summaryData: TableauDataTable | null;
    isLoading: boolean;
}

interface ValueField {
    id: string;
    field: string;
    agg: 'SUM' | 'AVG' | 'MIN' | 'MAX' | 'COUNT' | 'COUNTD';
}

interface SortConfig {
    direction: 'asc' | 'desc';
    type: 'alphabetic' | 'value' | 'manual';
    field?: string; // If type is 'value', which value field to sort by
}

interface CalculatedField {
    id: string;
    name: string;
    formula: string;
}

export const ConfigPanel = ({
    onClose,
    worksheets,
    selectedWorksheet,
    onSelectWorksheet,
    summaryData,
    isLoading
}: ConfigPanelProps) => {
    const [rows, setRows] = useState<string[]>([]);
    const [columns, setColumns] = useState<string[]>([]);
    const [values, setValues] = useState<ValueField[]>([]);

    const [showColumnGrandTotals, setShowColumnGrandTotals] = useState(true);
    const [columnGrandTotalsPosition, setColumnGrandTotalsPosition] = useState<'top' | 'bottom'>('top');

    const [showRowGrandTotals, setShowRowGrandTotals] = useState(false);
    const [rowGrandTotalsPosition, setRowGrandTotalsPosition] = useState<'left' | 'right'>('right');

    const [showSubtotals, setShowSubtotals] = useState(false);
    const [showPreviewModal, setShowPreviewModal] = useState(false);

    const [sortConfigs, setSortConfigs] = useState<Record<string, SortConfig>>({});
    const [manualSortOrders, setManualSortOrders] = useState<Record<string, string[]>>({});

    const [manualSortModal, setManualSortModal] = useState<{ isOpen: boolean, field: string | null }>({
        isOpen: false,
        field: null
    });

    // Calculation State
    const [calculatedFields, setCalculatedFields] = useState<CalculatedField[]>([]);
    const [showCalcEditor, setShowCalcEditor] = useState(false);
    const [editingCalc, setEditingCalc] = useState<CalculatedField | null>(null);

    const sensors = useSensors(
        useSensor(PointerSensor),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    );

    // Load saved settings on mount
    useEffect(() => {
        const loadSettings = async () => {
            try {
                // @ts-ignore
                if (window.tableau) {
                    // @ts-ignore
                    const savedConfigStr = window.tableau.extensions.settings.get('pivotConfig');
                    if (savedConfigStr) {
                        const savedConfig = JSON.parse(savedConfigStr);
                        if (savedConfig.rows) setRows(savedConfig.rows);
                        if (savedConfig.columns) setColumns(savedConfig.columns);
                        if (savedConfig.values) setValues(savedConfig.values);
                        if (savedConfig.showColumnGrandTotals !== undefined) setShowColumnGrandTotals(savedConfig.showColumnGrandTotals);
                        if (savedConfig.columnGrandTotalsPosition) setColumnGrandTotalsPosition(savedConfig.columnGrandTotalsPosition);
                        if (savedConfig.showRowGrandTotals !== undefined) setShowRowGrandTotals(savedConfig.showRowGrandTotals);
                        if (savedConfig.rowGrandTotalsPosition) setRowGrandTotalsPosition(savedConfig.rowGrandTotalsPosition);
                        if (savedConfig.showSubtotals !== undefined) setShowSubtotals(savedConfig.showSubtotals);
                        if (savedConfig.sortConfigs) setSortConfigs(savedConfig.sortConfigs);
                        if (savedConfig.manualSortOrders) setManualSortOrders(savedConfig.manualSortOrders);
                        if (savedConfig.calculatedFields) setCalculatedFields(savedConfig.calculatedFields);

                        // Legacy support
                        if (savedConfig.showGrandTotals !== undefined) setShowColumnGrandTotals(savedConfig.showGrandTotals);
                    }
                }
            } catch (e) {
                console.error("Failed to load settings", e);
                return PivotEngine.pivot(summaryData, {
                    rows,
                    columns,
                    values,
                    calculatedFields
                });
            }, [summaryData, rows, columns, values, calculatedFields]);

    const getUniqueValuesForField = (field: string): string[] => {
        if (!summaryData) return [];
        const colIndex = summaryData.columns.findIndex(c => c._fieldName === field);
        if (colIndex === -1) return [];

        const unique = new Set<string>();
        summaryData.data.forEach(row => {
            const val = row[colIndex];
            unique.add(val?.formattedValue || String(val?.value || ''));
        });
        return Array.from(unique).sort();
    };

    const handleSave = async () => {
        try {
            const config = {
                rows,
                columns,
                values,
                showColumnGrandTotals,
                columnGrandTotalsPosition,
                showRowGrandTotals,
                rowGrandTotalsPosition,
                showSubtotals,
                sortConfigs,
                manualSortOrders,
                calculatedFields
            };
            // @ts-ignore
            if (window.tableau) {
                // @ts-ignore
                window.tableau.extensions.settings.set('pivotConfig', JSON.stringify(config));
                // @ts-ignore
                await window.tableau.extensions.settings.saveAsync();
            } else {
                console.log("Saved config (local):", config);
            }
            onClose();
        } catch (e) {
            console.error("Failed to save settings", e);
            alert("Failed to save settings");
        }
    };

    const toggleField = (field: string, type: 'row' | 'col' | 'val') => {
        if (type === 'row') {
            if (rows.includes(field)) {
                setRows(rows.filter(r => r !== field));
            } else {
                setRows([...rows, field]);
                setColumns(columns.filter(c => c !== field));
                setValues(values.filter(v => v.field !== field));
            }
        } else if (type === 'col') {
            if (columns.includes(field)) {
                setColumns(columns.filter(c => c !== field));
            } else {
                setColumns([...columns, field]);
                setRows(rows.filter(r => r !== field));
                setValues(values.filter(v => v.field !== field));
            }
        } else if (type === 'val') {
            if (values.find(v => v.field === field)) {
                setValues(values.filter(v => v.field !== field));
            } else {
                setValues([...values, { id: `${field}-${Date.now()}`, field, agg: 'SUM' }]);
                setRows(rows.filter(r => r !== field));
                setColumns(columns.filter(c => c !== field));
            }
        }
    };

    const handleDragEnd = (event: DragEndEvent) => {
        const { active, over } = event;
        if (!over) return;

        if (active.id !== over.id) {
            if (rows.includes(active.id as string)) {
                setRows((items) => {
                    const oldIndex = items.indexOf(active.id as string);
                    const newIndex = items.indexOf(over.id as string);
                    return arrayMove(items, oldIndex, newIndex);
                });
            } else if (columns.includes(active.id as string)) {
                setColumns((items) => {
                    const oldIndex = items.indexOf(active.id as string);
                    const newIndex = items.indexOf(over.id as string);
                    return arrayMove(items, oldIndex, newIndex);
                });
            } else if (values.find(v => v.id === active.id)) {
                setValues((items) => {
                    const oldIndex = items.findIndex(v => v.id === active.id);
                    const newIndex = items.findIndex(v => v.id === over.id);
                    return arrayMove(items, oldIndex, newIndex);
                });
            }
        }
    };

    const updateSort = (field: string, type: 'alphabetic' | 'value' | 'manual', valueField?: string) => {
        if (type === 'manual') {
            setManualSortModal({ isOpen: true, field });
            return;
        }

        setSortConfigs(prev => {
            const current = prev[field] || { direction: 'asc', type: 'alphabetic' };
            let next: SortConfig;

            if (type === 'value' && valueField) {
                next = { direction: 'desc', type: 'value', field: valueField };
            } else {
                // Toggle direction if already alphabetic
                if (current.type === 'alphabetic') {
                    next = { ...current, direction: current.direction === 'asc' ? 'desc' : 'asc' };
                } else {
                    next = { direction: 'asc', type: 'alphabetic' };
                }
            }
            return { ...prev, [field]: next };
        });
    };

    const handleManualSortSave = (field: string, newOrder: string[]) => {
        setManualSortOrders(prev => ({
            ...prev,
            [field]: newOrder
        }));
        // Ensure the sort config is set to manual
        setSortConfigs(prev => ({
            ...prev,
            [field]: { direction: 'asc', type: 'manual' }
        }));
    };

    const handleSaveCalculation = (name: string, formula: string) => {
        if (editingCalc) {
            // Update existing
            setCalculatedFields(prev => prev.map(c => c.id === editingCalc.id ? { ...c, name, formula } : c));
        } else {
            // Create new
            setCalculatedFields(prev => [...prev, { id: `calc-${Date.now()}`, name, formula }]);
        }
        setEditingCalc(null);
    };

    const handleEditCalculation = (field: CalculatedField) => {
        setEditingCalc(field);
        setShowCalcEditor(true);
    };

    const renderPivotTable = () => {
        if (!pivotTree) return <p className="text-gray-500 text-sm italic">Configure rows/cols to see preview.</p>;

        // 1. Extract all unique column keys from the root, EXCLUDING grand total keys
        const allKeys = Object.keys(pivotTree.values)
            .filter(k => !k.startsWith('__grand_total__'))
            .sort();

        // 2. Build Header Hierarchy
        const headerLevels: { label: string, span: number }[][] = [];
        const totalLevels = columns.length + 1; // +1 for Value Field

        if (allKeys.length > 0) {
            for (let level = 0; level < totalLevels; level++) {
                const currentLevelHeaders: { label: string, span: number }[] = [];
                let lastLabel: string | null = null;
                let currentSpan = 0;

                allKeys.forEach((key, index) => {
                    const [colPart, valPart] = key.split('::');
                    const colValues = colPart ? colPart.split(' | ') : [];
                    const parts = [...colValues, valPart];

                    const label = parts[level] || '';

                    let sameAsPrevious = false;
                    if (lastLabel === label && index > 0) {
                        const prevKey = allKeys[index - 1];
                        const [prevColPart, prevValPart] = prevKey.split('::');
                        const prevColValues = prevColPart ? prevColPart.split(' | ') : [];
                        const prevParts = [...prevColValues, prevValPart];

                        let parentsMatch = true;
                        for (let p = 0; p < level; p++) {
                            if (parts[p] !== prevParts[p]) {
                                parentsMatch = false;
                                break;
                            }
                        }
                        if (parentsMatch) sameAsPrevious = true;
                    }

                    if (sameAsPrevious) {
                        currentSpan++;
                    } else {
                        if (lastLabel !== null) {
                            currentLevelHeaders.push({ label: lastLabel, span: currentSpan });
                        }
                        lastLabel = label;
                        currentSpan = 1;
                    }
                });
                if (lastLabel !== null) {
                    currentLevelHeaders.push({ label: lastLabel, span: currentSpan });
                }
                headerLevels.push(currentLevelHeaders);
            }
        }

        // 3. Helper to render rows recursively
        const renderRows = (node: any, depth = 0, path: string[] = []): ReactNode[] => {
            if (!node || !node.children) return [];
            const rowsNodes: ReactNode[] = [];

            // Sorting Logic
            const currentRowField = rows[depth];
            const sortConfig = sortConfigs[currentRowField];

            const sortedChildren = (Array.from(node.children.entries()) as any[]).sort((a: any, b: any) => {
                const keyA = a[0];
                const keyB = b[0];
                const nodeA = a[1];
                const nodeB = b[1];

                let comparison = 0;

                if (sortConfig?.type === 'manual') {
                    const manualOrder = manualSortOrders[currentRowField] || [];
                    const indexA = manualOrder.indexOf(keyA);
                    const indexB = manualOrder.indexOf(keyB);

                    // If both are in manual list, compare indices
                    if (indexA !== -1 && indexB !== -1) {
                        comparison = indexA - indexB;
                    }
                    // If only A is in list, A comes first
                    else if (indexA !== -1) {
                        comparison = -1;
                    }
                    // If only B is in list, B comes first
                    else if (indexB !== -1) {
                        comparison = 1;
                    }
                    // Fallback to alphabetic
                    else {
                        comparison = keyA.localeCompare(keyB, undefined, { numeric: true });
                    }
                } else if (sortConfig?.type === 'value' && sortConfig.field) {
                    // Sort by value
                    // If we have columns, we sort by the Row Grand Total of that value
                    // If no columns, we sort by the value directly
                    const valKey = columns.length > 0 ? `__grand_total__::${sortConfig.field}` : sortConfig.field;
                    const valA = nodeA.values[valKey] || 0;
                    const valB = nodeB.values[valKey] || 0;
                    comparison = valA - valB;
                } else {
                    // Default alphabetic sort
                    comparison = keyA.localeCompare(keyB, undefined, { numeric: true });
                }

                return sortConfig?.direction === 'desc' ? -comparison : comparison;
            });

            sortedChildren.forEach(([key, child]) => {
                const isLeaf = !child.children || child.children.size === 0;
                const showRow = isLeaf || showSubtotals;

                if (showRow) {
                    const rowCells = (
                        <>
                            {/* Render Row Headers */}
                            {rows.map((_, index) => {
                                let content = '';
                                if (index < depth) content = path[index];
                                else if (index === depth) content = key;
                                else content = isLeaf ? '' : 'Total';

                                return (
                                    <td key={index} className="p-2 border-b border-r text-sm truncate">
                                        {content}
                                    </td>
                                );
                            })}

                            {/* Row Grand Totals (Left) */}
                            {showRowGrandTotals && rowGrandTotalsPosition === 'left' && (
                                values.map(v => {
                                    const gtKey = columns.length > 0 ? `__grand_total__::${v.field}` : v.field;
                                    return (
                                        <td key={`gt-left-${v.id}`} className="p-2 border-b border-r text-sm text-right font-bold bg-gray-50">
                                            {child.values[gtKey]?.toLocaleString(undefined, { maximumFractionDigits: 2 }) || '-'}
                                        </td>
                                    );
                                })
                            )}

                            {/* Render Values */}
                            {allKeys.map(colKey => {
                                const val = child.values[colKey];
                                return (
                                    <td key={colKey} className="p-2 border-b text-sm text-right font-mono">
                                        {typeof val === 'number' ? val.toLocaleString(undefined, { maximumFractionDigits: 2 }) : '-'}
                                    </td>
                                );
                            })}

                            {/* Row Grand Totals (Right) */}
                            {showRowGrandTotals && rowGrandTotalsPosition === 'right' && (
                                values.map(v => {
                                    const gtKey = columns.length > 0 ? `__grand_total__::${v.field}` : v.field;
                                    return (
                                        <td key={`gt-right-${v.id}`} className="p-2 border-b border-l text-sm text-right font-bold bg-gray-50">
                                            {child.values[gtKey]?.toLocaleString(undefined, { maximumFractionDigits: 2 }) || '-'}
                                        </td>
                                    );
                                })
                            )}
                        </>
                    );

                    rowsNodes.push(
                        <tr key={[...path, key].join('::')} className={isLeaf ? "hover:bg-gray-50" : "bg-gray-50 font-semibold"}>
                            {rowCells}
                        </tr>
                    );
                }
                rowsNodes.push(...renderRows(child, depth + 1, [...path, key]));
            });
            return rowsNodes;
        };

        const renderColumnGrandTotals = () => (
            <tr className="bg-gray-50 font-bold border-b-2 border-t-2">
                <td
                    colSpan={Math.max(1, rows.length)}
                    className="p-2 border-r text-sm sticky left-0 bg-gray-50"
                >
                    Grand Total
                </td>
                {/* Row GT Left Placeholder */}
                {showRowGrandTotals && rowGrandTotalsPosition === 'left' && (
                    <td colSpan={values.length} className="p-2 border-r bg-gray-100"></td>
                )}

                {allKeys.map(colKey => (
                    <td key={colKey} className="p-2 border-r text-sm text-right">
                        {pivotTree.values[colKey]?.toLocaleString(undefined, { maximumFractionDigits: 2 }) || '-'}
                    </td>
                ))}

                {/* Row GT Right Placeholder */}
                {showRowGrandTotals && rowGrandTotalsPosition === 'right' && (
                    values.map(v => {
                        const gtKey = columns.length > 0 ? `__grand_total__::${v.field}` : v.field;
                        return (
                            <td key={`gt-total-${v.id}`} className="p-2 border-l text-sm text-right bg-gray-100">
                                {pivotTree.values[gtKey]?.toLocaleString(undefined, { maximumFractionDigits: 2 }) || '-'}
                            </td>
                        );
                    })
                )}
            </tr>
        );

        return (
            <div className="min-w-full inline-block align-middle">
                <div className="border rounded-lg overflow-hidden">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                            {/* Column Headers */}
                            {headerLevels.map((levelHeaders, levelIndex) => (
                                <tr key={levelIndex}>
                                    {/* Row Header Placeholders (only on first row) */}
                                    {levelIndex === 0 && (
                                        <th
                                            colSpan={Math.max(1, rows.length)}
                                            rowSpan={headerLevels.length}
                                            className="p-2 border-r text-left text-xs font-medium text-gray-500 uppercase tracking-wider sticky left-0 bg-gray-50 z-10"
                                        >
                                            {rows.join(' / ') || 'Rows'}
                                        </th>
                                    )}

                                    {/* Row GT Left Header */}
                                    {levelIndex === 0 && showRowGrandTotals && rowGrandTotalsPosition === 'left' && (
                                        <th
                                            colSpan={values.length}
                                            rowSpan={headerLevels.length}
                                            className="p-2 border-r text-center text-xs font-bold text-gray-700 uppercase bg-gray-100"
                                        >
                                            Grand Total
                                        </th>
                                    )}

                                    {levelHeaders.map((header, hIndex) => (
                                        <th
                                            key={hIndex}
                                            colSpan={header.span}
                                            className="p-2 border-r text-center text-xs font-medium text-gray-500 uppercase tracking-wider"
                                        >
                                            {header.label}
                                        </th>
                                    ))}

                                    {/* Row GT Right Header */}
                                    {levelIndex === 0 && showRowGrandTotals && rowGrandTotalsPosition === 'right' && (
                                        <th
                                            colSpan={values.length}
                                            rowSpan={headerLevels.length}
                                            className="p-2 border-l text-center text-xs font-bold text-gray-700 uppercase bg-gray-100"
                                        >
                                            Grand Total
                                        </th>
                                    )}
                                </tr>
                            ))}
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {columnGrandTotalsPosition === 'top' && showColumnGrandTotals && renderColumnGrandTotals()}
                            {renderRows(pivotTree)}
                            {columnGrandTotalsPosition === 'bottom' && showColumnGrandTotals && renderColumnGrandTotals()}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    };

    return (
        <div className="flex flex-col h-full bg-white relative">
            <div className="flex items-center justify-between p-4 border-b">
                <h2 className="text-xl font-semibold">Configuration</h2>
                <div className="flex gap-2">
                    <button
                        onClick={() => setShowPreviewModal(true)}
                        className="px-4 py-2 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 text-sm font-medium border"
                    >
                        Preview Table
                    </button>
                    <button
                        onClick={handleSave}
                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-medium"
                    >
                        Save Configuration
                    </button>
                    <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                        Close
                    </button>
                </div>
            </div>
            <div className="flex-1 p-4 flex flex-col overflow-hidden">
                <div className="mb-6 shrink-0">
                    <label className="block text-sm font-medium text-gray-700 mb-2">Select Worksheet</label>
                    <select
                        className="w-full p-2 border rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
                        value={selectedWorksheet?.name || ''}
                        onChange={(e) => {
                            const ws = worksheets.find(w => w.name === e.target.value);
                            if (ws) onSelectWorksheet(ws);
                        }}
                    >
                        <option value="">-- Select a Worksheet --</option>
                        {worksheets.map(ws => (
                            <option key={ws.name} value={ws.name}>{ws.name}</option>
                        ))}
                    </select>
                </div>

                {isLoading && <div className="text-blue-600">Loading data...</div>}

                {summaryData && (
                    <div className="grid grid-cols-12 gap-4 flex-1 min-h-0">
                        {/* Field List */}
                        <div className="col-span-4 border p-4 rounded-md overflow-auto bg-gray-50 flex flex-col">
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="font-medium text-sm uppercase text-gray-500">Available Fields</h3>
                                <button
                                    onClick={() => { setEditingCalc(null); setShowCalcEditor(true); }}
                                    className="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200"
                                >
                                    + Create Calc
                                </button>
                            </div>
                            <div className="flex-1 overflow-y-auto">
                                {availableColumns.map(col => (
                                    <div key={col.fieldName} className={`mb-2 p-2 border rounded shadow-sm text-sm ${col.isCalculated ? 'bg-purple-50 border-purple-200' : 'bg-white'}`}>
                                        <div className="flex justify-between items-center mb-1">
                                            <div className="font-medium truncate flex items-center gap-1" title={col.fieldName}>
                                                {col.isCalculated && <span className="text-purple-600 font-bold">=</span>}
                                                {col.fieldName}
                                            </div>
                                            <div className="flex items-center gap-1">
                                                <span className="text-[10px] text-gray-400 bg-gray-100 px-1 rounded uppercase">{col.dataType}</span>
                                                {col.isCalculated && (
                                                    <button
                                                        onClick={() => handleEditCalculation(calculatedFields.find(c => c.name === col.fieldName)!)}
                                                        className="text-xs text-gray-400 hover:text-blue-600"
                                                        title="Edit Calculation"
                                                    >
                                                        âœŽ
                                                    </button>
                                                )}
                                            </div>
                                        </div>
                                        <div className="flex gap-1">
                                            <button
                                                onClick={() => toggleField(col.fieldName, 'row')}
                                                className={`px-2 py-0.5 text-xs rounded ${rows.includes(col.fieldName) ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 hover:bg-gray-200'}`}
                                            >
                                                Row
                                            </button>
                                            <button
                                                onClick={() => toggleField(col.fieldName, 'col')}
                                                className={`px-2 py-0.5 text-xs rounded ${columns.includes(col.fieldName) ? 'bg-green-100 text-green-700' : 'bg-gray-100 hover:bg-gray-200'}`}
                                            >
                                                Col
                                            </button>
                                            <button
                                                onClick={() => toggleField(col.fieldName, 'val')}
                                                className={`px-2 py-0.5 text-xs rounded ${values.find(v => v.field === col.fieldName) ? 'bg-orange-100 text-orange-700' : 'bg-gray-100 hover:bg-gray-200'}`}
                                            >
                                                Val
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Configuration Area */}
                        <div className="col-span-8 flex flex-col gap-4 overflow-auto">
                            <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                                {/* Rows */}
                                <div className="border p-3 rounded-md flex-1 bg-blue-50/30">
                                    <h3 className="font-medium mb-2 text-sm text-blue-800">Rows</h3>
                                    <SortableContext items={rows} strategy={verticalListSortingStrategy}>
                                        {rows.map(row => (
                                            <SortableItem
                                                key={row}
                                                id={row}
                                                label={row}
                                                onRemove={() => toggleField(row, 'row')}
                                                extraControls={
                                                    <div className="flex items-center gap-1 mr-2">
                                                        <button
                                                            onClick={() => updateSort(row, 'alphabetic')}
                                                            className={`text-xs px-1 rounded border ${sortConfigs[row]?.type === 'alphabetic' ? 'bg-blue-200 border-blue-400' : 'bg-white'}`}
                                                            title="Sort A-Z"
                                                        >
                                                            {sortConfigs[row]?.type === 'alphabetic' && sortConfigs[row].direction === 'desc' ? 'Z-A' : 'A-Z'}
                                                        </button>
                                                        <button
                                                            onClick={() => updateSort(row, 'manual')}
                                                            className={`text-xs px-1 rounded border ${sortConfigs[row]?.type === 'manual' ? 'bg-blue-200 border-blue-400' : 'bg-white'}`}
                                                            title="Manual Sort"
                                                        >
                                                            Man
                                                        </button>
                                                        {values.length > 0 && (
                                                            <select
                                                                className={`text-xs border rounded max-w-[80px] ${sortConfigs[row]?.type === 'value' ? 'bg-blue-200 border-blue-400' : ''}`}
                                                                value={sortConfigs[row]?.type === 'value' ? sortConfigs[row].field : ''}
                                                                onChange={(e) => updateSort(row, 'value', e.target.value)}
                                                            >
                                                                <option value="">Sort By...</option>
                                                                {values.map(v => (
                                                                    <option key={v.id} value={v.field}>{v.field}</option>
                                                                ))}
                                                            </select>
                                                        )}
                                                    </div>
                                                }
                                            />
                                        ))}
                                    </SortableContext>
                                </div>

                                {/* Columns */}
                                <div className="border p-3 rounded-md flex-1 bg-green-50/30">
                                    <h3 className="font-medium mb-2 text-sm text-green-800">Columns</h3>
                                    <SortableContext items={columns} strategy={verticalListSortingStrategy}>
                                        {columns.map(col => (
                                            <SortableItem key={col} id={col} label={col} onRemove={() => toggleField(col, 'col')} />
                                        ))}
                                    </SortableContext>
                                </div>

                                {/* Values */}
                                <div className="border p-3 rounded-md flex-1 bg-orange-50/30">
                                    <h3 className="font-medium mb-2 text-sm text-orange-800">Values</h3>
                                    <SortableContext items={values.map(v => v.id)} strategy={verticalListSortingStrategy}>
                                        {values.map(val => (
                                            <SortableItem
                                                key={val.id}
                                                id={val.id}
                                                label={val.field}
                                                onRemove={() => toggleField(val.field, 'val')}
                                                extraControls={
                                                    <select
                                                        className="text-xs border rounded p-1 mr-2"
                                                        value={val.agg}
                                                        onChange={(e) => {
                                                            const newValues = values.map(v => v.id === val.id ? { ...v, agg: e.target.value as any } : v);
                                                            setValues(newValues);
                                                        }}
                                                    >
                                                        <option value="SUM">SUM</option>
                                                        <option value="AVG">AVG</option>
                                                        <option value="MIN">MIN</option>
                                                        <option value="MAX">MAX</option>
                                                        <option value="COUNT">CNT</option>
                                                        <option value="COUNTD">CNTD</option>
                                                    </select>
                                                }
                                            />
                                        ))}
                                    </SortableContext>
                                </div>
                            </DndContext>
                        </div>
                    </div>
                )
                }
            </div >

            {/* Preview Modal */}
            {
                showPreviewModal && (
                    <div className="absolute inset-0 z-50 bg-black/50 flex items-center justify-center p-8">
                        <div className="bg-white rounded-lg shadow-xl w-full h-full flex flex-col overflow-hidden">
                            <div className="flex justify-between items-center p-4 border-b">
                                <h3 className="text-lg font-semibold">Pivot Table Preview</h3>
                                <button
                                    onClick={() => setShowPreviewModal(false)}
                                    className="text-gray-500 hover:text-gray-700"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </button>
                            </div>

                            {/* Controls Section */}
                            <div className="p-4 border-b bg-gray-50 space-y-3">
                                <div className="flex flex-wrap gap-4">
                                    {/* Column Grand Totals */}
                                    <div className="flex items-center gap-2">
                                        <input
                                            type="checkbox"
                                            id="modal-col-gt"
                                            checked={showColumnGrandTotals}
                                            onChange={(e) => setShowColumnGrandTotals(e.target.checked)}
                                            className="rounded"
                                        />
                                        <label htmlFor="modal-col-gt" className="text-sm font-medium">Column Grand Totals</label>
                                        {showColumnGrandTotals && (
                                            <select
                                                value={columnGrandTotalsPosition}
                                                onChange={(e) => setColumnGrandTotalsPosition(e.target.value as 'top' | 'bottom')}
                                                className="text-xs border rounded px-2 py-1"
                                            >
                                                <option value="top">Top</option>
                                                <option value="bottom">Bottom</option>
                                            </select>
                                        )}
                                    </div>

                                    {/* Row Grand Totals */}
                                    <div className="flex items-center gap-2">
                                        <input
                                            type="checkbox"
                                            id="modal-row-gt"
                                            checked={showRowGrandTotals}
                                            onChange={(e) => setShowRowGrandTotals(e.target.checked)}
                                            className="rounded"
                                        />
                                        <label htmlFor="modal-row-gt" className="text-sm font-medium">Row Grand Totals</label>
                                        {showRowGrandTotals && (
                                            <select
                                                value={rowGrandTotalsPosition}
                                                onChange={(e) => setRowGrandTotalsPosition(e.target.value as 'left' | 'right')}
                                                className="text-xs border rounded px-2 py-1"
                                            >
                                                <option value="left">Left</option>
                                                <option value="right">Right</option>
                                            </select>
                                        )}
                                    </div>

                                    {/* Subtotals */}
                                    <div className="flex items-center gap-2">
                                        <input
                                            type="checkbox"
                                            id="modal-subtotals"
                                            checked={showSubtotals}
                                            onChange={(e) => setShowSubtotals(e.target.checked)}
                                            className="rounded"
                                        />
                                        <label htmlFor="modal-subtotals" className="text-sm font-medium">Show Subtotals</label>
                                    </div>
                                </div>
                            </div>

                            <div className="flex-1 overflow-auto p-4">
                                {renderPivotTable()}
                            </div>
                        </div>
                    </div>
                )
            }

            {/* Manual Sort Modal */}
            {
                manualSortModal.isOpen && manualSortModal.field && (
                    <ManualSortModal
                        isOpen={manualSortModal.isOpen}
                        onClose={() => setManualSortModal({ isOpen: false, field: null })}
                        field={manualSortModal.field}
                        initialItems={getUniqueValuesForField(manualSortModal.field)}
                        currentOrder={manualSortOrders[manualSortModal.field] || []}
                        onSave={handleManualSortSave}
                    />
                )
            }

            {/* Calculation Editor Modal */}
            <CalculationEditor
                isOpen={showCalcEditor}
                onClose={() => setShowCalcEditor(false)}
                onSave={handleSaveCalculation}
                initialName={editingCalc?.name}
                initialFormula={editingCalc?.formula}
                fields={summaryData?.columns.map(c => c.fieldName) || []}
            />
        </div >
    );
};
